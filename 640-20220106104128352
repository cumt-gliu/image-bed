![image-20220708154224962](/Users/gliu/learn-notes/images/image-20220708154224962.png)

### 可见性、原子性、有序性问题：并发编程bug的源头

为了平衡cpu、内存、I/O设备所做的操作

1. cpu增加了缓存，以均衡与内存的速度差异
2. 操作系统增加了进程、线程，以分时复用cpu,进而均衡CPU与IO设备的速度差异
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理的利用

- 缓存导致的可见性问题
- 线程切换带来的原子性问题
- 编译优化带来的有序性问题

### Java内存模型：解决Java可见行和有序性问题

- Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体体现在volatile、synchronized、final和happens-before
- happens-before规则
  - 程序中顺序性规则
  - volatile变量规则
  - 传递性
  - 管程中锁的规则
  - 线程中start规则
  - 线程join规则

### 互斥锁：解决原子性问题

- Synchronized对象锁和类锁的区别
- Synchronized必须形成互斥
- Synchronized保护多个资源

### 死锁

- 细粒度锁提高并行度，性能优化的重要手段，可能会导致死锁
- 死锁发生的条件
  - 互斥
  - 占有且等待
  - 不可抢占
  - 循环等待

### 安全性和活跃性问题

- 存在共享数据并且该数据会发生变化时，即会出现数据竞争
- 竞态条件:程序的执行结果依赖线程执行的顺序
- 活锁：互相谦让
- 性能指标
  - 吞吐量：单位时间内能处理的请求数量
  - 延迟：指的是从发出请求到收到响应的时间
  - 并发量：能同时处理的请求数量

### 线程

![image-20220708220744328](/Users/gliu/learn-notes/images/image-20220708220744328.png)

- 提升性能的本质上就是提升硬件的利用率：提升I/O的利用率和CPU的利用率
- 设置多少线程合适：
  - cpu密集型：cpu+1
  - io密集型：cpu核数*（1+io耗时/cpu耗时）